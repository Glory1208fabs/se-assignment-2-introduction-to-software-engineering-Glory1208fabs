[![Review Assignment Due Date](https://classroom.github.com/assets/deadline-readme-button-24ddc0f5d75046c5622901739e7c5dd533143b0c8e959d652212380cedb1ea36.svg)](https://classroom.github.com/a/-ucQIGTc)
[![Open in Visual Studio Code](https://classroom.github.com/assets/open-in-vscode-718a45dd9cf7e7f842a935f5ebbe5719a5e09af4491e668f4dbf3b35d5cca122.svg)](https://classroom.github.com/online_ide?assignment_repo_id=15246679&assignment_repo_type=AssignmentRepo)
# SE-Assignment-2
Assignment: Introduction to Software Engineering
Instructions:
Answer the following questions based on your understanding of software engineering concepts. Provide detailed explanations and examples where appropriate.

Questions:
Define Software Engineering:

Answer:Software engineering is a discipline that involves applying engineering principles to the design, development, testing, and maintenance of software systems. It encompasses a systematic, disciplined, and quantifiable approach to the entire software development process, from initial concept to deployment and beyond.

What is software engineering, and how does it differ from traditional programming?
Software Development Life Cycle (SDLC):

Answer: Software engineering is a structured approach to software development that emphasizes systematic methods, rigorous processes, and best practices to ensure the creation of high-quality, reliable, and maintainable software systems. It involves the application of engineering principles to the entire software development process, from requirements analysis and design to implementation, testing, deployment, and maintenance.

Traditional programming, on the other hand, often refers to the act of writing code to solve a specific problem or implement a particular feature without necessarily following a formalized process. While traditional programming can produce functional software, it may lack the systematic approach and long-term perspective that software engineering provides. Traditional programming may focus more on short-term solutions rather than considering broader issues such as scalability, maintainability, and robustness.

The Software Development Life Cycle (SDLC) is a framework that describes the stages involved in the development of software from inception to retirement.

Software engineering applies principles and practices throughout each phase of the SDLC to ensure that the resulting software meets quality standards, is reliable, and can be maintained effectively over its lifecycle. It emphasizes a systematic and disciplined approach to software development, which distinguishes it from traditional programming methods

Explain the various phases of the Software Development Life Cycle. Provide a brief description of each phase.
Agile vs. Waterfall Models:

Software Development Life Cycle (SDLC) Phases:

Requirement Analysis: This phase involves gathering, analyzing, and documenting the requirements for the software system. It's crucial to understand the needs of users and stakeholders to define the scope and objectives of the project.

Design: In this phase, a blueprint or plan for the software solution is created. This includes designing the system architecture, database structure, user interface, and other components. The goal is to produce a detailed technical specification that guides the implementation phase.

Implementation: Developers write code based on the design specifications. This phase involves translating technical requirements into executable software by writing, testing, and integrating code modules.

Testing: Software is evaluated to identify and fix defects, ensuring it meets specified requirements and functions correctly under various conditions. This includes unit testing, integration testing, system testing, and user acceptance testing.

Deployment: Once the software has been thoroughly tested and approved, it's deployed to the production environment. This involves installing, configuring, and migrating the software to the target infrastructure.

Maintenance: After deployment, the software enters the maintenance phase. Here, it's monitored, updated, and modified to address bugs, enhance functionality, and adapt to changing requirements or technology.

Agile vs. Waterfall Models:

Agile Model: Agile is an iterative and flexible approach to software development. It emphasizes collaboration, adaptability, and customer feedback throughout the entire development process. In Agile, the SDLC is divided into smaller iterations or sprints, typically lasting from 1 to 4 weeks. Each sprint involves all phases of the SDLC, from requirements analysis to deployment and maintenance. Agile allows for continuous improvement and the ability to respond quickly to changes in requirements or priorities.

Waterfall Model: Waterfall is a sequential and linear approach to software development. It follows a strict order of phases, where each phase must be completed before moving on to the next. In the Waterfall model, requirements are gathered and analyzed upfront, followed by design, implementation, testing, deployment, and maintenance. This rigid structure makes it difficult to accommodate changes late in the development process and may lead to lengthy development cycles.

Compare and contrast the Agile and Waterfall models of software development. What are the key differences, and in what scenarios might each be preferred?
Requirements Engineering:

Answer: 
Key Differences:
Approach: Agile is iterative and adaptive, while Waterfall is sequential and rigid.
Flexibility: Agile is highly flexible and responsive to change, while Waterfall is less adaptable to changing requirements.
Customer Involvement: Agile involves continuous customer feedback and collaboration, while Waterfall typically has less customer involvement after the requirements are finalized.
Documentation: Waterfall relies more on upfront documentation, while Agile values working software over comprehensive documentation.
Risk Management: Agile mitigates risks through iterative development and frequent feedback, while Waterfall addresses risks through comprehensive planning and documentation.

Preferred Scenarios:
Agile: Agile is preferred for projects with evolving or uncertain requirements, where flexibility, adaptability, and customer collaboration are essential. It's well-suited for projects where rapid delivery of value is a priority.

Waterfall: Waterfall is preferred for projects with well-defined and stable requirements, where predictability, comprehensive planning, and documentation are critical. It's suitable for projects with strict regulatory requirements or fixed deadlines.

Requirements Engineering:
In both Agile and Waterfall models, Requirements Engineering plays a crucial role in understanding and documenting the needs and expectations of stakeholders. However, the approach to Requirements Engineering differs between the two models:

Agile: In Agile, Requirements Engineering is ongoing and iterative. Requirements are initially captured at a high level, and then detailed gradually as the project progresses through each iteration. The focus is on capturing just enough requirements to start development, with the understanding that requirements will evolve over time based on feedback from stakeholders and the working product.

Waterfall: In Waterfall, Requirements Engineering is typically done upfront during the requirements analysis phase. The emphasis is on gathering and documenting all requirements comprehensively before moving on to the next phase. Changes to requirements are discouraged once they are finalized, as they may disrupt the sequential flow of the project.

What is requirements engineering? Describe the process and its importance in the software development lifecycle.
Software Design Principles:

Answer:
Requirements Engineering:
Requirements engineering is the process of gathering, analyzing, documenting, and managing software requirements throughout the software development lifecycle. It involves understanding the needs and expectations of stakeholders, translating them into a set of detailed and unambiguous requirements, and ensuring that the resulting software solution meets those requirements.

Process of Requirements Engineering:
Elicitation: Gathering requirements from stakeholders through interviews, surveys, workshops, and observation. The goal is to understand the needs, preferences, and constraints of all parties involved.

Analysis: Analyzing and prioritizing requirements to identify conflicting or ambiguous requirements, missing information, and dependencies. This phase involves clarifying requirements and resolving any discrepancies.

Specification: Documenting requirements in a clear, concise, and unambiguous manner. This may involve using various techniques such as use cases, user stories, functional and non-functional requirements, and acceptance criteria.

Validation: Validating requirements with stakeholders to ensure that they accurately capture their needs and expectations. This may involve reviews, walkthroughs, prototypes, and simulations to confirm that the requirements are feasible and achievable.

Management: Managing requirements throughout the software development lifecycle, including tracking changes, managing dependencies, and ensuring traceability between requirements and other artifacts.

Importance of Requirements Engineering:

Understanding User Needs: Requirements engineering helps to ensure that the software solution addresses the needs and preferences of users and stakeholders, leading to increased user satisfaction and adoption.

Minimizing Risks: Properly defined and documented requirements reduce the risk of project failure by providing clarity and direction to the development team. It helps to identify potential risks early in the project lifecycle and mitigate them proactively.

Controlling Costs and Schedule: Clear and well-defined requirements facilitate accurate estimation of project costs, timelines, and resource requirements. It helps in managing project budgets and schedules effectively.

Improving Communication: Requirements engineering promotes effective communication and collaboration among stakeholders, development teams, and other project participants. It ensures that everyone has a common understanding of the project goals and expectations.

Enabling Change Management: Requirements engineering provides a structured framework for managing changes to project requirements. It allows for the evaluation of proposed changes in terms of their impact on project scope, schedule, and resources.

Software Design Principles:
Software design principles are fundamental concepts and guidelines that govern the process of designing software systems. They help in creating software that is scalable, maintainable, and adaptable to changing requirements. 


Explain the concept of modularity in software design. How does it improve maintainability and scalability of software systems?
Testing in Software Engineering:

Answer: 
Modularity in software design refers to the practice of breaking down a software system into smaller, independent modules or components, each responsible for a specific aspect of functionality. These modules are designed to be self-contained and loosely coupled, meaning they can be developed, tested, and maintained independently of each other. Each module typically has well-defined interfaces or APIs that specify how it interacts with other modules.

How Modularity Improves Maintainability:
Isolation of Changes: Modularity allows changes to be localized within individual modules, minimizing the impact on other parts of the system. This makes it easier to understand and predict the consequences of changes, reducing the risk of unintended side effects.

Ease of Debugging: With modular design, it's easier to isolate and debug issues within specific modules, as they are self-contained and have well-defined boundaries. This speeds up the debugging process and reduces the time and effort required to identify and fix defects.

Code Reusability: Modular design promotes code reusability by allowing modules to be reused in different parts of the system or in other projects. This reduces duplication of code and effort, leading to more efficient development and maintenance.

Scalability: Modular systems are easier to scale, as new functionality can be added by introducing new modules or extending existing ones. This allows the system to grow and evolve over time without requiring major restructuring or redesign.

How Modularity Improves Scalability:

Ease of Extension: Modular systems are easier to extend and enhance, as new functionality can be added by introducing new modules or extending existing ones. This facilitates incremental development and allows the system to evolve over time in response to changing requirements.

Parallel Development: Modularity enables parallel development by allowing multiple teams to work on different modules simultaneously. This reduces development time and improves productivity, especially in large and complex projects.

Component Reusability: Modular design promotes component reusability, as modules can be reused in different contexts or projects. This reduces the need to reinvent the wheel and accelerates the development process, particularly for common or generic functionality.

Scalable Deployment: Modular systems can be deployed in a scalable manner, with individual modules deployed and scaled independently as needed. This allows for more efficient resource utilization and better performance, especially in distributed or cloud-based environments.

Testing in Software Engineering:
Testing in software engineering refers to the process of evaluating a software system or component to ensure that it meets specified requirements and functions correctly under various conditions. Testing is an essential part of the software development lifecycle and helps identify defects, errors, and vulnerabilities early in the development process.

Describe the different levels of software testing (unit testing, integration testing, system testing, acceptance testing). Why is testing crucial in software development?
Version Control Systems:

Answer: 
Different Levels of Software Testing:
Unit Testing: Unit testing involves testing individual units or components of the software in isolation. These units are typically functions, methods, or classes. The purpose of unit testing is to verify that each unit behaves as expected and functions correctly according to its specifications. Unit tests are usually automated and are executed frequently during the development process to catch defects early.

Integration Testing: Integration testing verifies that the interaction between different units or components of the software works as intended. It focuses on testing the interfaces and interactions between modules to ensure that they integrate seamlessly and function correctly together. Integration testing can be performed at various levels, such as module-level integration, subsystem integration, or end-to-end integration.

System Testing: System testing evaluates the entire software system as a whole to ensure that it meets specified requirements and functions correctly in its intended environment. System testing verifies the system's functionality, performance, reliability, and usability under various conditions. It includes testing both functional and non-functional aspects of the software, such as user interfaces, data integrity, security, and performance.

Acceptance Testing: Acceptance testing validates that the software meets the needs and expectations of end-users or stakeholders. It focuses on verifying that the software satisfies the specified requirements and performs as expected in real-world scenarios. Acceptance testing can take different forms, such as user acceptance testing (UAT), business acceptance testing (BAT), or operational acceptance testing (OAT), depending on the stakeholders involved and the objectives of the testing.

Why is Testing Crucial in Software Development?
Quality Assurance: Testing ensures that the software meets specified requirements and functions correctly under various conditions. It helps identify defects, errors, and vulnerabilities early in the development process, leading to higher quality and reliability.

Risk Mitigation: Testing helps mitigate risks by identifying and addressing potential issues before they impact end-users or stakeholders. It helps minimize the likelihood of software failures, data breaches, and other adverse events.

Validation and Verification: Testing validates that the software meets the needs and expectations of end-users and verifies that it conforms to specified requirements. It ensures that the software delivers the intended value and performs as expected.

Cost Savings: Testing helps reduce the cost of software development by identifying and fixing defects early in the development process. It minimizes the need for rework, retesting, and customer support, leading to lower development costs and faster time-to-market.

Customer Satisfaction: Testing helps ensure that the software meets the needs and expectations of end-users, leading to increased customer satisfaction and loyalty. It helps build trust and confidence in the software product, enhancing its reputation and market competitiveness.

Compliance and Regulatory Requirements: Testing ensures that the software complies with relevant standards, regulations, and industry best practices. It helps demonstrate due diligence and regulatory compliance, reducing the risk of legal and financial penalties.

Version Control Systems:
Version Control Systems (VCS) are software tools that enable developers to track changes to source code and collaborate on software development projects. They provide a centralized repository for storing and managing code, allowing multiple developers to work on the same codebase simultaneously while keeping track of changes, versions, and revisions.

What are version control systems, and why are they important in software development? Give examples of popular version control systems and their features.
Software Project Management:

Answer:
Version Control Systems (VCS) are software tools that enable developers to manage changes to source code and other files in a collaborative environment. They provide a centralized repository where developers can store, track, and manage different versions of their codebase. Version control systems help teams collaborate effectively, track changes, maintain code quality, and manage project history.

Importance of Version Control Systems in Software Development:
Collaboration: VCS allows multiple developers to work on the same codebase simultaneously without interfering with each other's changes. It enables collaboration by providing tools for sharing code, reviewing changes, and resolving conflicts.

Change Tracking: VCS tracks changes to the codebase over time, including who made the changes, when they were made, and what changes were made. This helps developers understand the history of the project and revert to previous versions if needed.

Code Integrity: VCS helps maintain the integrity of the codebase by providing mechanisms for code review, approval, and validation. It ensures that only authorized changes are merged into the main codebase and that changes are properly documented and reviewed.

Backup and Recovery: VCS serves as a backup and disaster recovery mechanism by storing code in a centralized repository. It helps protect against data loss and system failures by providing a secure and reliable backup of the codebase.

Branching and Merging: VCS allows developers to create branches to work on new features or experimental changes without affecting the main codebase. Branches can be merged back into the main codebase once the changes are completed and tested.

Code Reusability: VCS promotes code reusability by providing a centralized repository for storing and sharing code. It allows developers to reuse code across different projects and collaborate on common libraries and components.

Examples of Popular Version Control Systems and Their Features:
Git: Git is one of the most widely used version control systems. It is distributed, meaning that each developer has a complete copy of the codebase, including its history. Git supports branching and merging, allowing developers to work on different features or fixes in parallel and merge changes back into the main codebase. It also provides tools for code review, conflict resolution, and collaboration. Git is popular for its speed, flexibility, and extensive ecosystem of tools and services.

Subversion (SVN): Subversion is a centralized version control system that stores code in a central repository. It supports branching and merging, but with a centralized model where all changes are made directly to the central repository. Subversion provides features for versioning, branching, tagging, and merging, but it is less flexible and scalable compared to distributed version control systems like Git.

Mercurial: Mercurial is a distributed version control system similar to Git. It provides features for branching, merging, and distributed development, allowing developers to work offline and synchronize changes later. Mercurial is known for its simplicity, ease of use, and scalability, making it suitable for both small and large projects.

Perforce: Perforce is a centralized version control system designed for large-scale development projects. It provides features for versioning, branching, merging, and code review, as well as advanced features for managing large codebases and distributed teams. Perforce is popular in industries such as gaming, automotive, and aerospace, where scalability, performance, and security are critical.


Software Project Management:
Software project management involves planning, organizing, and coordinating activities related to the development of software systems. It encompasses processes, methodologies, tools, and techniques for managing software projects from inception to completion, ensuring that they are delivered on time, within budget, and according to specified requirements.

Discuss the role of a software project manager. What are some key responsibilities and challenges faced in managing software projects?
Software Maintenance:

Answer:
The role of a software project manager is critical in ensuring the successful planning, execution, and delivery of software projects. A software project manager is responsible for overseeing all aspects of a software project, from initiation to closure, and for ensuring that the project meets its objectives, requirements, and deadlines. Here are some key responsibilities and challenges faced in managing software projects:

Key Responsibilities of a Software Project Manager:
Project Planning: Developing a comprehensive project plan that outlines project objectives, scope, schedule, budget, resources, and deliverables. The project plan serves as a roadmap for the project team and provides a framework for project execution and control.

Resource Management: Allocating and managing resources, including human resources, equipment, and materials, to ensure that project tasks are completed on time and within budget. This involves identifying resource requirements, assigning roles and responsibilities, and monitoring resource utilization throughout the project lifecycle.

Risk Management: Identifying, assessing, and mitigating risks that may impact the success of the project. Risk management involves identifying potential risks and uncertainties, analyzing their potential impact, developing risk mitigation strategies, and monitoring risks throughout the project lifecycle.

Stakeholder Management: Engaging and communicating with project stakeholders, including customers, sponsors, team members, and other relevant parties. Stakeholder management involves identifying stakeholder needs and expectations, managing stakeholder relationships, and addressing stakeholder concerns and issues.

Quality Management: Ensuring that the software meets specified quality standards and customer expectations. Quality management involves defining quality objectives, establishing quality assurance processes, conducting quality reviews and inspections, and implementing corrective actions to address defects and deficiencies.

Change Management: Managing changes to project scope, schedule, and requirements throughout the project lifecycle. Change management involves assessing change requests, evaluating their impact on project objectives, and implementing approved changes in a controlled and systematic manner.

Monitoring and Control: Monitoring project progress, performance, and compliance with project plans and objectives. Monitoring and control involve tracking project metrics, identifying variances and deviations from the plan, and taking corrective actions to address issues and ensure project success.

Challenges Faced in Managing Software Projects:
Scope Creep: Changes to project scope, requirements, or objectives that are not properly managed can lead to scope creep, causing delays, cost overruns, and quality issues.

Resource Constraints: Limited availability of resources, including skilled personnel, funding, and equipment, can pose challenges in meeting project deadlines and objectives.

Technical Complexity: Software projects often involve complex technologies, architectures, and requirements, which can increase the risk of technical challenges, such as integration issues, performance bottlenecks, and compatibility issues.

Schedule Pressures: Tight deadlines and aggressive project schedules can put pressure on the project team and increase the risk of errors, defects, and quality issues.

Communication Barriers: Poor communication among project stakeholders, including team members, customers, and sponsors, can lead to misunderstandings, conflicts, and delays in project delivery.

Risk Uncertainty: Uncertainty and unpredictability in project risks, such as technical risks, market risks, and regulatory risks, can pose challenges in identifying, assessing, and mitigating risks effectively.

Change Management: Managing changes to project scope, requirements, and priorities can be challenging, especially in dynamic and evolving environments where requirements may change frequently.

Software Maintenance:
Software maintenance refers to the process of modifying, updating, and enhancing software after it has been deployed in production. It involves making changes to software to address defects, improve performance, enhance functionality, adapt to changes in requirements or technology, and comply with evolving standards and regulations. Software maintenance is an essential aspect of the software development lifecycle and is necessary to ensure that software remains reliable, secure, and effective over time

Define software maintenance and explain the different types of maintenance activities. Why is maintenance an essential part of the software lifecycle?
Ethical Considerations in Software Engineering:

Answer:
Software maintenance refers to the process of modifying, updating, and enhancing software after it has been deployed in production. It involves making changes to software to address defects, improve performance, enhance functionality, adapt to changes in requirements or technology, and comply with evolving standards and regulations. Software maintenance is an essential aspect of the software development lifecycle and is necessary to ensure that software remains reliable, secure, and effective over time.

Types of Software Maintenance Activities:
Corrective Maintenance: Correcting defects, errors, and problems identified in the software during testing or operation. Corrective maintenance aims to restore the software to a working state and eliminate any malfunctions or deficiencies that may impact its performance or functionality.

Adaptive Maintenance: Adapting the software to changes in its operating environment, such as hardware upgrades, operating system changes, or changes in regulatory requirements. Adaptive maintenance ensures that the software remains compatible and functional in its intended environment, even as external factors evolve.

Perfective Maintenance: Enhancing the software to improve its performance, reliability, usability, or maintainability. Perfective maintenance involves making enhancements or optimizations to the software to meet evolving user needs and expectations, improve user experience, and streamline software operations.

Preventive Maintenance: Proactively identifying and addressing potential issues or vulnerabilities in the software before they impact its performance or functionality. Preventive maintenance aims to reduce the likelihood of future problems by identifying and mitigating risks, improving code quality, and implementing best practices for software development and maintenance.

Why is Maintenance an Essential Part of the Software Lifecycle?
Ensures Software Reliability: Maintenance activities, such as corrective maintenance, help address defects and errors in the software, ensuring that it remains reliable and performs as expected in its intended environment.

Adapts to Changing Requirements: Adaptive maintenance allows software to adapt to changes in its operating environment, such as technological advancements, regulatory changes, or evolving user needs, ensuring that it remains relevant and effective over time.

Improves Software Quality: Perfective maintenance activities, such as enhancements and optimizations, help improve the quality, performance, and usability of the software, enhancing user experience and satisfaction.

Protects Against Security Risks: Maintenance activities, such as preventive maintenance, help identify and address potential security vulnerabilities in the software, protecting it against security threats and ensuring the confidentiality, integrity, and availability of sensitive data.

Extends Software Lifespan: By addressing defects, adapting to changes, improving quality, and protecting against risks, maintenance activities help extend the lifespan of the software, maximizing its value and return on investment for stakeholders.


Ethical Considerations in Software Engineering:
Ethical considerations in software engineering involve identifying, assessing, and addressing ethical issues and dilemmas that arise in the development, deployment, and use of software systems. These ethical considerations encompass a wide range of issues, including privacy, security, transparency, accountability, fairness, and social responsibility. Ethical considerations are essential for ensuring that software systems are developed and used in a manner that aligns with ethical principles and values and that respects the rights and interests of individuals and society as a whole.

What are some ethical issues that software engineers might face? How can software engineers ensure they adhere to ethical standards in their work?

Answer:
Software engineers may face a variety of ethical issues in their work, including:

Privacy: Software engineers may be tasked with developing systems that collect, store, and process personal or sensitive information. Ensuring the privacy of this data and complying with relevant privacy laws and regulations can be a significant ethical concern.

Security: Developing secure software systems that protect against unauthorized access, data breaches, and cyberattacks is essential. Failing to prioritize security measures can lead to ethical issues, such as exposing users to risks of identity theft or financial loss.

Transparency: Software engineers should strive to ensure transparency in the design and functionality of their systems. This includes providing clear documentation, user interfaces, and disclosures about how data is collected, used, and shared.

Bias and Discrimination: Bias can inadvertently be introduced into software systems through factors such as biased training data or algorithmic biases. Software engineers should be aware of these issues and take steps to mitigate bias to ensure fair and equitable outcomes.

Fairness: Ensuring that software systems do not unfairly discriminate against individuals or groups based on factors such as race, gender, ethnicity, religion, or socioeconomic status is crucial. Engineers must carefully consider the potential impacts of their designs and algorithms on different populations.

Intellectual Property: Respect for intellectual property rights, including copyrights, patents, and trade secrets, is essential in software development. Engineers must ensure that they do not infringe on the intellectual property rights of others and that they respect licensing agreements and open-source licenses.

Environmental Impact: Software engineers should consider the environmental impact of their work, including factors such as energy consumption, electronic waste, and carbon emissions. Developing energy-efficient software and minimizing resource consumption can help mitigate environmental concerns.

To adhere to ethical standards in their work, software engineers can take several steps:
Stay Informed: Stay informed about ethical guidelines, principles, and best practices relevant to software engineering, such as the ACM Code of Ethics and Professional Conduct or IEEE Code of Ethics.

Continued Education: Engage in ongoing education and training on ethical issues in software engineering. This may include attending workshops, seminars, or online courses on topics such as privacy, security, fairness, and bias in software systems.

Ethical Decision-Making: Develop ethical decision-making skills to recognize and address ethical dilemmas that arise in software development. Consider the potential impacts of design decisions on users, stakeholders, and society as a whole.

Collaboration: Collaborate with multidisciplinary teams, including ethicists, legal experts, and stakeholders, to address ethical considerations in software development comprehensively.

Documentation and Transparency: Document design decisions, data sources, algorithms, and privacy practices transparently to ensure accountability and enable users to make informed choices about their use of software systems.

Ethical Review: Consider conducting ethical reviews or impact assessments of software projects to identify and mitigate potential ethical risks and implications.

Advocacy: Advocate for ethical considerations in software development within your organization and the broader software engineering community. Promote discussions and initiatives that prioritize ethical values and principles in software engineering practice


Submission Guidelines:
Your answers should be well-structured, concise, and to the point.
Provide real-world examples or case studies wherever possible.
Cite any references or sources you use in your answers.
Submit your completed assignment by [due date].










